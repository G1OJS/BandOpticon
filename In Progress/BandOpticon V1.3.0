<!DOCTYPE html>
<html lang="en">
<head>
<title>BandOpticon V1.2.1</title>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
	
<style>
:root {background-color: #91FCFE; color:black;text-align: left; font-size: 1.3vmax; }
div {margin: 0px;  padding: 0px;}
#title {text-align: center; font-size: 5rem;}
#subtitle {text-align: center; font-size: 1.5rem; margin-bottom:10px;}
#app_group {margin:2px;padding:0px; background-color:blue;}
#appTop {display: grid; grid-template-columns: minmax(30%,max-content) auto; grid-template-rows: auto;}
#appTop > div {background-color: white; margin: 2px;  padding: 5px;}
#legend > div {background-color: white; margin: 2px;  padding: 5px;  }
#details_group {margin:2px;padding:0px; background-color:blue;}
#detailsTop {display: grid; grid-template-columns: minmax(30%,max-content) auto; grid-template-rows: auto;}
#detailsTop > div {background-color: white; margin: 0px;  padding: 5px; padding-bottom:15px; font-size: 1rem; border-right:solid; border-color:grey; border-width:1px; }
#detailsGrid {display: grid; grid-template-columns: 20% min-content auto; grid-template-rows: auto; border-top:solid; border-width:1px; }
#detailsGrid > div {background-color: white; margin: 0px; border-bottom:solid; border-right:solid; border-color:grey; border-width:1px; 
		    margin-bottom:0px; padding-left: 5px; padding-bottom:1px; font-size: 0.8rem; min-height:10px; }
#detailsGrid > div.titleRow {padding:5px; padding-bottom:15px; font-size: 0.8rem; font-weight:bold;}
#bandsGrid {display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; margin: 1px;}
#bandsGrid > div {background-color: rgb(230, 230, 255); margin: 1px;  padding: 5px; }
#creditsGrid {color:black; font-size: 0.7rem; display: grid; grid-template-columns: auto auto auto;}
.hanging20 {text-indent:-20px; padding-left:20px; margin-top: 0px; margin-bottom: 0px;}
.notesText {color:grey; font-weight:normal; font-size: 0.8rem;}
.hidden {display: none;}
.Tx {color:red;}
.Rx {color:green; }
.TxRx {color:blue; font-style:italic;}
.IntraHome_farEnd {color:blue; }
.Tx_farEnd {color:Fuchsia; }
.Rx_farEnd {color:olive;}
.TxRx_farEnd {color:blue; font-style:italic;}
.HighlightPos {background-color:#d1d1e0;}
.HighlightNeg {background-color:#ffff66;}
//.HighlightNeg {text-decoration:underline;}
.textAnchorButton {color: blue; }
.textAnchorButton-strong {color: blue; font-weight:bold;}
a:link {color: blue;}
a:visited {color: blue;}
</style>
</head>
<body>
<div id="title">BandOpticon</div>
<div id="subtitle"> Live <a href='https://pskreporter.info/'>Pskreporter</a> statistics for all bands between Home and DX</div>
 
<div id="app_group">
   <div id="appTop">
      <div id="appTop_l"></div>
      <div id="appTop_r"></div>
   </div>
   <div id="legend"></div>
   <div id="details_group">
     <div id="detailsTop"></div>
     <div id="detailsGrid"></div>
   </div>
   <div id="bandsGrid"></div>
</div>

<div id="creditsGrid">
    <div>
        Javascript & HTML developed by Alan Robinson:<br>
        <a href='https://www.qrz.com/db/G1OJS'>G1OJS @QRZ.com</a><br>
        <a href='https://www.instagram.com/g1ojs_alan/'>G1OJS_alan@instagram.com</a><br>
        <a href='https://g1ojs.github.io/'>G1OJS Ham Radio @GitHub</a><br>
        <a href="mailto:G1OJS@yahoo.com">G1OJS@yahoo.com</a>
   </div>
   <div>
        Thanks to:<br>
        Philip Gladstone - N1DQ for <a href='https://pskreporter.info/'>Pskreporter.info</a><br>
        Tom Fanning - M0LTE for <a href='http://mqtt.pskreporter.info/'>mqtt.pskreporter.info</a>, the MQTT feed for this app<br>
        <a href='https://www.unpkg.com/browse/mqtt@5.10.1/README.md'>www.unpkg.com</a> for the cdn MQTT library used here <a href='https://www.unpkg.com/browse/mqtt@5.10.1/LICENSE.md'>MIT license</a>
   </div>
   <div>
      License: <a href='https://github.com/G1OJS/BandOpticon/blob/main/LICENSE'>MIT license</a><br>
      Readme: <a href='https://g1ojs.github.io/BandOpticon/'>g1ojs.github.io/BandOpticon</a><br>
      GitHub: <a href='https://github.com/G1OJS/BandOpticon/'>github.com/G1OJS/BandOpticon</a><br>
      Changes: <a href='https://g1ojs.github.io/BandOpticon/Change%20History.html'>Change History</a><br>
	   
      <a href="https://hits.seeyoufarm.com"><img alt="Seeyoufarm HitCounter" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://g1ojs.github.io/BandOpticon/BandOpticon"></a>                        
   </div>
</div>

<!--Get the library for MQTT functions -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

<!-- BandOpticon script -->
<script>

 // initialisation and functions to load and save configuration
 
  const bandsArr=["160m","80m","60m","40m","30m","20m","17m","15m","12m","10m","6m","4m","2m","70cm","23cm"];
  const defaultSquaresList="IO50:99,JO01,JO02,JO03"; // used if squaresList value can't be set from localstorage
  let squaresArr=[]; // contains the full list of every square (level 4, 6, 8, 10) that we want to watch, generated from squaresList
  var squaresList=""; // the human-firendly list of squares to watch
  var watchedMode="FT8";
  var modesArr=["FT4","FT8","JS8","WSPR","CW"];
  var detailsBand=bandsArr[0];
  var bandTilesSortKey="BandName";
  var refresh_mSeconds=5000;
  var purgeMinutes=15;
  var detailsWanted="BandTileLegend";
  var entityDisplayType="Square";
  var squaresDisplayLevel=4;
  var groupHomeEntities=true;
  let myCall="G1OJS";
  var mqttClient=null;	
  var tStart=Date.now(); // software start time
  const RIGHTARROW="<span style='text-align:center; font-size:1rem;'>&#8680</span>";
  const LEFTARROW="<span style='text-align:center; font-size:1rem;'>&#8678</span>";
  const LEFTRIGHTARROW="<span style='text-align:center; font-size:1rem;'>&#8660</span>";
  const spotsLegend="<span class='IntraHome_farEnd'> Home "+RIGHTARROW+" Home /</span>"
         + "<span class='Tx_farEnd'> Home "+RIGHTARROW+" DX /</span>"
         + "<span class='Rx_farEnd'> DX "+RIGHTARROW+" Home</span>"
  var dataForRecord="";
  var newWindow=null;
  var dataWriteSeconds=15;
  var connections = {};
  var reciprocals=new Set;
  var connectionsAdded=0;
  var connectionsPurged=0;
  var messagesReceived=0;

  var once=true;

  loadConfig();
  setDisplayConfig();
  updateappTop();

  setInterval(updateDisplays, refresh_mSeconds);
  setInterval(writeData, 1000*dataWriteSeconds);

  connectToFeed();

  // Write the <div>s for each band summary tile in the bandsGrid area
  var toAdd = document.createDocumentFragment();
  for(let i=0; i < bandsArr.length; i++){
    var newDiv = document.createElement('div');  
    newDiv.id="bandTile"+i;
    newDiv.innerHTML=""
      +"<output id='"+bandsArr[i]+"__title-modeLink'>"+bandsArr[i]+"</output></a>"
      +"<output id='"+bandsArr[i]+"__spots'></output><br>"
      +"<output id='"+bandsArr[i]+"__calls'></output><br>"
      +"<output id='"+bandsArr[i]+"__modes' style='font-size:0.7rem'></output>";
    toAdd.appendChild(newDiv);
  }
  document.getElementById('bandsGrid').appendChild(toAdd);

  // ***********************************
  // * End of main: Functions below    *
  // ***********************************

  // ++++++ MQTT functions +++++++++++++
  
   function connectToFeed(){
  //pskr/filter/v2/{band}/{mode}/{sendercall}/{receivercall}/{senderlocator}/{receiverlocator}/{sendercountry}/{receivercountry}
    // the following works but ideally we need to verify disconnection and spots set to zero before reconnecting. 
    // Should also alert the user that this will happen and give chance not to edit the squares.
    // if already connected, disconnect (happens if user edits squares list)
    try{mqttClient.end(); console.log("Asked to end mqtt stream");} catch {}
    // now connect and subscribe on success
    mqttClient=mqtt.connect("wss://mqtt.pskreporter.info:1886");
    mqttClient.onSuccess=subscribe();
    mqttClient.on("message", (filter,message) => {onMessage(message.toString());}  );
  }
  

  
  function subscribe(){
    //pskr/filter/v2/{band}/{mode}/{sendercall}/{receivercall}/
    //{senderlocator}/{receiverlocator}/{sendercountry}/{receivercountry}
    
    // find the level 4 squares we need to subscribe to in order to get messages for our squares in squaresArr
    let subs=new Set;
    for(let i=0;i<squaresArr.length;i++){subs.add(squaresArr[i].substring(0,4));}
    let subsArr=Array.from(subs);
    
    // now subscribe to the level 4 squares
    subsArr.forEach((sq) => {
      var topic='pskr/filter/v2/+/+/+/+/'+sq+'/+/+/#';
      console.log("Subscribe to "+topic);
      mqttClient.subscribe(topic, (error) => {if (error) {
              console.error('subscription failed to '+topic, error)}});
      var topic='pskr/filter/v2/+/+/+/+/+/'+sq+'/+/#';
      console.log("Subscribe to "+topic);
      mqttClient.subscribe(topic, (error) => {if (error) {
              console.error('subscription failed to '+topic, error)}});
    } );
  }
  
  function onMessage(msg){
    // message format:
    // sq:sequence number b:band f:frequency md:mode rp:report (snr) t:seconds since 1970-01-01
    // sc/rc:sender call/receiver call sl/rl:sender locator/receiver locator sa/ra:sender ADIF/receiver ADIF
	  
    // first, build conn object for this msg using same keys as PSKR MQTT:
    const conn={};
    msg.slice(1, -1).replaceAll('"','').split(',')
         .forEach(function(v) {
           let kvp=v.split(":");
           conn[kvp[0]]=kvp[1];
         });
    messagesReceived+=1;

    if(bandsArr.indexOf(conn.b)<0) {return} // don't process bands we aren't watching
	  
    // now swap keys to: 
    // sq:sequence, t:time, b:band, md:mode, dd:direction = hh,hd or dh
    // hc:home, call hl:home loc, cc:connected call, cl:connected call loc
    if(squareIsInHome(conn.sl)){
      conn["hc"]=conn.sc.toUpperCase();
      conn["hl"]=conn.sl.toUpperCase();
      conn["cc"]=conn.rc.toUpperCase();
      conn["cl"]=conn.rl.toUpperCase();
      if(squareIsInHome(conn.rl)) {conn["dd"]="hh"} else {conn["dd"]="hd"}      
    } else {
      conn["hc"]=conn.rc.toUpperCase();
      conn["hl"]=conn.rl.toUpperCase();
      conn["cc"]=conn.sc.toUpperCase();
      conn["cl"]=conn.sl.toUpperCase();
      conn["dd"]="dh";
    }
    delete conn["sc"]; delete conn["sl"]; delete conn["sa"];
    delete conn["rc"]; delete conn["rl"]; delete conn["ra"];
    delete conn["f"]; delete conn["rp"];
    
    // now add this connection to the connections object using sequence ID as key:
    connections[conn.sq]=conn;
    connectionsAdded+=1;
  }
  
   function purgeSpots(){
   // get rid of spots older than purgeMinutes
   // connectionsPurged+=1;
     for (id in connections) {
       let tConn=parseInt(connections[id].t);
       let connAge=((Date.now()/1000-tConn))/60
       if(connAge > purgeMinutes) {
         delete connections[id];
         connectionsPurged+=1;
       }
     }
   }
   


  function setDisplayConfig(newWant,band){

    const allowed=["Nothing","BandTileLegend","BandDetails"];
    if(!(typeof newWant==='undefined')) {
      if(!allowed.includes(newWant)) {
        console.log("Unknown detail type passed to setDisplayConfig: "+newWant);
      } else {
        detailsWanted=newWant; console.log("New details pane content requested: ",newWant,band);
      }
    }
    
    if(detailsWanted=="Nothing") {
      legend.innerHTML="";
      detailsGrid.innerHTML="";
      detailsTop.innerHTML="";
    }
    
    if(detailsWanted=="BandTileLegend"){showBandTileLegend()} 
    
    if(detailsWanted=="BandDetails"){
      detailsBand=band;
      showBandDetails()
    } 
    
  }
  
  function showBandTileLegend(){
    legend.innerHTML="<div>Band tile legend:"
      +" <a class='textAnchorButton' href='#' onclick='setDisplayConfig(&quot;Nothing&quot;)'><span style='float:right;';>close</span></a>"
      +"<br><span class='textAnchorButton-strong'>Band & Mode</span> (click for detailed stats)<br><strong>Spots</strong>: number of spots "+spotsLegend+"<br>"
      +"<span class='Tx'>Tx Calls: number of unique calls in 'Home' received by anyone</span><br>"
      +"<span class='Rx'>Rx Calls: number of unique calls in 'Home' receiving anyone</span><br>"
      +"<span class='TxRx'>TxRx Calls: number of unique calls in 'Home' receiving anyone and being received by anyone</span><br>"
      +"<span class='textAnchorButton'>+ Other modes in use on this band</span>"
      +"<br><span class='textAnchorButton'>Click any underlined number to sort band tiles on that number</span>"
      +"</div>"
;

      detailsGrid.innerHTML="";
      detailsTop.innerHTML="";
  
  }

  // function to write HTML to the appTop box
  function updateappTop(){
    var now = new Date;
    var utc_timestamp=get_utc_timestamp(now);
    var runningmins=Math.trunc(((now-tStart)/1000) / 60);
    var modeSelector="";
    modesArr.forEach((md) => {modeSelector+=" <a class='textAnchorButton' href='#' onclick='watchedMode=&quot;"+md+"&quot;; updateDisplays();'>"+md+"</a> "});
    
    appTop_l.innerHTML="<div><strong>"+utc_timestamp+"</strong>"
       +"<br>Running for "+runningmins+" minutes<br>"
       +(connectionsAdded-connectionsPurged)+" connections in database: "+connectionsAdded+" added, "+connectionsPurged+" purged<br>"
       +messagesReceived+" messages received<br>";

    let squaresListDisplay=squaresList.replaceAll(',',', '); // add spaces to give an opportunity for linebreaks
    appTop_r.innerHTML=""
	+"<span style='float:right;'><a class='textAnchorButton' href='#' onclick='startRecording();'>record</a></span>"
        +"My call = "+myCall+" <a class='textAnchorButton' href='#' onclick='editMyCall();'>edit</a><br>"
        +" Spots purged if older than "+purgeMinutes+" mins <a class='textAnchorButton' href='#' onclick='editPurgeMins();'>edit</a><br>"
        +"Mode: "+modeSelector+"<br>"
        +"<p class='hanging20'>Home = "+squaresListDisplay+" <a class='textAnchorButton' href='#' onclick='editSquaresList();'>edit</a></p>"
        +"Currently sorting band tiles on <output id='Legend__bandTilesSortKey'></output> <a href='#' onclick='setSort(&quot;BandName&quot;)'>reset</a>";
        
        document.getElementById("Legend__bandTilesSortKey").innerHTML=bandTilesSortKey;
  }
  
  function getEntity(call,square){
    if(entityDisplayType=="Call"){return call;}
    if(entityDisplayType=="Square"){return square.substring(0,squaresDisplayLevel);}
    if(entityDisplayType=="CallSquare"){return call+"-"+square.substring(0,squaresDisplayLevel);} 
  }
	  
  function HL(item,pattern,hlClass1="HighlightPos",hlClass2=""){
    // returns highlighted text using class hlClass1 (default HighlightPos) if either item==pattern or pattern==true
    // otherwise, returns item unless hlClass2 is specified in which case returns highlighted text using class HighlightNeg
  if (item==", ") {return item} // don't highlight comma-spaces
  if(item==pattern || pattern==true){
        return "<span class="+hlClass1+">"+item+"</span>";
    } else {
	    if(hlClass2==""){
	      return item;
	    } else {
	      return "<span class="+hlClass2+">"+item+"</span>";
	    }
    }
  }
  
  function validSquaresListEntry(locator){
    // if a valid level 4,6,8 or 10 square, return the level else return 0
    // odd numbers represent the xxxxxxxYY:ZZ version of the n-1 type
    if(RegExp("^[A-R]{2}[0-9]{2}$").test(locator)) {return 4};
    if(RegExp("^[A-R]{2}[0-9]{2}:[0-9]{2}$").test(locator)) {return 5};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}$").test(locator)) {return 6};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}:[A-X]{2}$").test(locator)) {return 7};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}[0-9]{2}$").test(locator)) {return 8};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}[0-9]{2}:[0-9]{2}$").test(locator)) {return 9};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}[0-9]{2}[A-X]{2}$").test(locator)) {return 10};
    if(RegExp("^[A-R]{2}[0-9]{2}[A-X]{2}[0-9]{2}[A-X]{2}:[A-X]{2}$").test(locator)) {return 11};
    return 0;
  }

  function squareIsInHome(sq){
    // return true if the level 4, 6, 8 or 10 square sq is in the home squares array
    return (squaresArr.includes(sq.substring(0,4)) || squaresArr.includes(sq.substring(0,6)) || squaresArr.includes(sq.substring(0,8)) || squaresArr.includes(sq.substring(0,10)));
  }

  function parseSquares(sqsList){
    // returns uppercase squares, expanded if necessary
    var outputSqsArr=new Array();
    var inputSqs=sqsList.toUpperCase().split(','); // internally we work with uppercase squares
    console.log("Parsing squares list "+inputSqs);
    for(i=0;i<inputSqs.length;i++){
      let sq=inputSqs[i];
      let cln=sq.search(":");
      if(cln<0){
        outputSqsArr.push(sq)
      } else {
        let root=sq.substring(0,cln-2);
        for(let x=sq.charCodeAt(cln-2);x<sq.charCodeAt(cln+1)+1;x++){
          for(let y=sq.charCodeAt(cln-1);y<sq.charCodeAt(cln+2)+1;y++){
            outputSqsArr.push(root+String.fromCharCode(x)+String.fromCharCode(y))
          }
        }
      }   
    }
    console.log("Parsed squares result "+outputSqsArr);
    return outputSqsArr;
  }
   	
   function get_utc_timestamp(){ 
    var t=new Date;
    return t.getUTCDate()+"/"+(t.getUTCMonth()+1)+"/"+t.getUTCFullYear()+" "
       +("0"+t.getUTCHours()).slice(-2)+":"
       +("0"+t.getUTCMinutes()).slice(-2)+":"
       +("0"+t.getUTCSeconds()).slice(-2)+" UTC";
  }

  function startRecording(){
    newWindow = window.open("", "newWindow", "width=1800, height=300");
    let htmlTmp="BandOpticon recording data once every "+dataWriteSeconds+" seconds."
    +"'Home' = "+squaresList
    +"<br><strong>Time (UTC), Mode, n times [Band, nSpots Home-Home, nSpots Home->DX, nSpots DX->Home, n(callsigns transmitting in Home), n(callsigns receiving in Home), n(callsigns transmitting and receiving in home)]</strong><BR> ";
  	  newWindow.document.write(htmlTmp);
  }
  
  function writeData(){
    if(newWindow==null){return}
    var data_html="<br>"+get_utc_timestamp()+","+dataForRecord.slice(0,-1);
    newWindow.document.write(data_html);
  }
	
  function saveConfig(){
      console.log("Saving config:");
      localStorage.setItem('squaresList', JSON.stringify(squaresList));
      console.log("Saved Squares List: "+squaresList);
      localStorage.setItem('myCall', myCall);
      console.log("Saved myCall: "+myCall);
      localStorage.setItem('purgeMinutes', purgeMinutes);
      console.log("Saved purgeMinutes: "+purgeMinutes);
  }
  
  function loadConfig(){
    if(localStorage.getItem('squaresList')){
      squaresList=JSON.parse(localStorage.getItem('squaresList'));
    } else {
      squaresList=defaultSquaresList;
      console.log("No local config data found for squares list: defaults applied.");
      saveConfig();
    }
    squaresArr=parseSquares(squaresList); // returns uppercase squares, expanded if necessary
    
    if(localStorage.getItem('myCall')){
      myCall=localStorage.getItem('myCall');
    } else {
      myCall="G1OJS";
      saveConfig();
    }
	  
    if(localStorage.getItem('purgeMinutes')){
      purgeMinutes=localStorage.getItem('purgeMinutes');
    } else {
      purgeMinutes=5;
      saveConfig();
    }
  }

 
    // needs validation code
  function editMyCall(){
    var resp=prompt("Enter your callsign",myCall);
    if(resp==null){return}
    myCall=resp.toUpperCase();
    localStorage.setItem('myCall',myCall);
    updateappTop();
    setDisplayConfig();
  }
  
  function editPurgeMins(){
    var resp=prompt("Enter minutes for spot expiry",purgeMinutes);
    if(resp==null){return}
    if(!Number.isNaN(parseInt(resp))){
      if(parseInt(resp)>0 && parseInt(resp)<60){
          purgeMinutes=parseInt(resp);
          localStorage.setItem('purgeMinutes',purgeMinutes);
          updateappTop();
          return
      } else {alert("Please enter a number between 1 and 59")}
    } else  {alert("Please enter a number between 1 and 59")}
  }
  
  // function to allow the user to edit the home squares list
  function editSquaresList(){
    var resp=prompt("Please enter a list of squares (level 4,6,8 or 10) separated by commas.\n\n"
		   +"To specify a rectangle within a larger square, use a colon to \n"
		   +"separate the 'lower left' and 'top right' corners.g. IO50:85, IO50ab:pq\n\n"
		   +"Input example: IO50:85,JO01,JO03ku,JO80:87",squaresList);
    if(resp==null){return}
    let respArr=resp.toUpperCase().split(','); // validSquaresListEntry() requires uppercase even though we allow squaresList to be mixed case
    squaresListValid=true;
    for (let i=0;i<respArr.length;i++){
      if(validSquaresListEntry(respArr[i])<4) squaresListValid=false;
    }
    if(squaresListValid){
      console.clear();
      squaresList=resp; // potentially mixed case but that's OK
      console.log("Squares list updated to: "+resp);
      saveConfig();
      squaresArr=parseSquares(resp); // returns uppercase squares, expanded if necessary
      connections = {};
      connectionsAdded=0;
      connectionsPurged=0;
      messagesReceived=0;
      updateappTop();
      updateDisplays();
      connectToFeed();
    } else {
      alert("Please enter a comma-separated list of valid squares LLNN or smaller.\n\nYou entered "+resp);
    }
  }

  function updateDisplays(){
 //     console.log("Update Displays");
      purgeSpots();
      updateappTop();
      dataForRecord="Mode="+watchedMode+", ";
      sortBandTiles();
//      console.log("Update Band Tiles");
      bandsArr.forEach((band) => updateBandTile(band));
      if(detailsWanted=="BandDetails") {
        showBandDetails();
        resizeGridColumns();
      }
      showBandsHeard();
  }

  function showBandsHeard(){
    var bandsHeard=new Set();
    for (id in connections) {bandsHeard.add(connections[id].b)}
    console.log(Array.from(bandsHeard).toSorted()).
  }
  
  function resizeGridColumns(){
  
    // find the largest counts of characters in the LH and RH columns
    const farEntities=document.querySelectorAll('[class$="_farEntities"]');
    const homeCalls=document.querySelectorAll('[class$="_homeCalls"]');
 
     // redistribute grid columns
    let gridDiv=document.getElementById('detailsGrid');
    if (groupHomeEntities) {
      let lhCharsCount=0;   
      let rhCharsCount=0;
      if (homeCalls[0]!=undefined && farEntities[0]!=undefined){
        Array.from(homeCalls).forEach((cell) => {lhCharsCount=Math.max(lhCharsCount,cell.innerText.length)});
        Array.from(farEntities).forEach((cell) => {rhCharsCount=Math.max(rhCharsCount,cell.innerText.length)});
		}
      let centreColumnNominalChars=7;
      let p1=Math.round(100*Math.min(Math.max(lhCharsCount/(lhCharsCount+rhCharsCount+centreColumnNominalChars),0.1),0.5));
      gridDiv.style.gridTemplateColumns = "minmax(min-content,"+p1+"%) min-content auto";
    } else {
      gridDiv.style.gridTemplateColumns = "min-content min-content auto";
    }
  }
  
  
 function setSort(sortKey){
   console.log("Set sort key");
   bandTilesSortKey=sortKey;
   document.getElementById("Legend__bandTilesSortKey").innerHTML=bandTilesSortKey;
   updateDisplays();
 } 
  
 function sortBandTiles(){
  
    let criteria=new Array();
    let indexArr=new Array();
    let sortVal=0;
//    console.log("Sort band tiles");

    bandsArr.forEach((band,index) => {
      switch (bandTilesSortKey) {
  			case 'BandName': sortVal=-index; break;
        case 'nH2H': sortVal=parseInt(document.getElementById(band+"__spots-nH2H").innerText); break;
        case 'nH2DX': sortVal=parseInt(document.getElementById(band+"__spots-nH2DX").innerText); break;
        case 'nDX2H': sortVal=parseInt(document.getElementById(band+"__spots-nDX2H").innerText); break;
        case 'nTx': sortVal=parseInt(document.getElementById(band+"__calls-nTx").innerText); break;
        case 'nRx': sortVal=parseInt(document.getElementById(band+"__calls-nRx").innerText); break;
        case 'nTxRx': sortVal=parseInt(document.getElementById(band+"__calls-nTxRx").innerText); break;
      }
      criteria.push(sortVal); 
      indexArr.push(index);
    });
    indexArr=indexArr.sort((a, b) => criteria[b]-criteria[a]);
    indexArr.forEach((newIndex,index) => {
      let div=document.getElementById("bandTile"+index);
      let outputs=div.querySelectorAll("output");
      outputs.forEach((op) => {op.id=bandsArr[newIndex]+"__"+(op.id).split("__")[1]});
     });
  }
  
	  
  function updateBandTile(band){
       
       let nSpotsH2H=0;
       let nSpotsH2DX=0;
       let nSpotsDX2H=0;
       let txCalls=new Set;
       let rxCalls=new Set;
   
   //    console.log("Update Band Tile "+band);
       // update first row of the band tile
       let htmlTmp=" <a class='textAnchorButton-strong' href='#' onclick='setDisplayConfig(&quot;BandDetails&quot;,&quot;"+band+"&quot;);'>"+band+" "+watchedMode+"</a>";
       if(detailsWanted!="BandTileLegend") {
         htmlTmp+=" <a class='textAnchorButton' href='#' onclick=setDisplayConfig(&quot;BandTileLegend&quot;);><span style='float:right;';>legend</span></a>";
       }
       document.getElementById(band+"__title-modeLink").innerHTML=htmlTmp+"<br>";
             
       for (id in connections) {
         let conn=connections[id];
         if (conn.b==band && conn.md==watchedMode) {
           if(conn.dd=="hh") {nSpotsH2H+=1; txCalls.add(conn.hc);}
           if(conn.dd=="hd") {nSpotsH2DX+=1; txCalls.add(conn.hc);}
           if(conn.dd=="dh") {nSpotsDX2H+=1; rxCalls.add(conn.hc);}
         }
       }
       
       // save the stats from above to the recording string
       dataForRecord+=band+","+nSpotsH2H+","+nSpotsH2DX+","+nSpotsDX2H+","+txCalls.size+","+rxCalls.size+","+txCalls.intersection(rxCalls).size+",";
       
       // write the counts for this band's band tile
       document.getElementById(band+"__spots").innerHTML="Spots "
         +"<a href='#' onclick='setSort(&quot;nH2H&quot;)'><span class='IntraHome_farEnd' id='"+band+"__spots-nH2H'>"+nSpotsH2H+"</span></a>/"
         +"<a href='#' onclick='setSort(&quot;nH2DX&quot;)'><span class='Tx_farEnd' id='"+band+"__spots-nH2DX'>"+nSpotsH2DX+"</span></a>/"
         +"<a href='#' onclick='setSort(&quot;nDX2H&quot;)'><span class='Rx_farEnd' id='"+band+"__spots-nDX2H'>"+nSpotsDX2H+"</span></a>";
       document.getElementById(band+"__calls").innerHTML=
         "<span class='Tx'>Tx Calls:</span> <a href='#' onclick='setSort(&quot;nTx&quot;)'><span class='Tx' id='"+band+"__calls-nTx'>"+txCalls.size+"</span></a><br>"
         +"<span class='Rx'>Rx Calls:</span> <a href='#' onclick='setSort(&quot;nRx&quot;)'><span class='Rx' id='"+band+"__calls-nRx'>"+rxCalls.size+"</span></a><br>"
         +"<span class='TxRx'>TxRx Calls:</span> <a href='#' onclick='setSort(&quot;nTxRx&quot;)'><span class='TxRx' id='"+band+"__calls-nTxRx'>"+txCalls.intersection(rxCalls).size+"</span></a>";

       // set background colour of band tile to grey if no activity
       let parentBox=document.getElementById(band+"__calls").parentElement
       if((txCalls.size+rxCalls.size)==0){parentBox.style.background="#e6e6ff"} else {parentBox.style.background="white"}

       // find the other modes are we hearing on this band and write clickable links for BandActivityDetails
        let otherModesOnThisBand=new Set(); // will rise and fall in size as connections arrive and are purged
        let globalModes=new Set(modesArr); // modesArr will accumulate over the script run time
        for (id in connections) {
          if(connections[id].b==band) {
            if(connections[id].md!=watchedMode) {otherModesOnThisBand.add(connections[id].md)};
            globalModes.add(connections[id].md);
          }
        }
        modesArr=Array.from(globalModes);
        const op=document.getElementById(bandsArr[bandsArr.indexOf(band)]+"__modes");
        op.innerHTML="";
        Array.from(otherModesOnThisBand).forEach((md) =>{
          op.innerHTML+="<a class='textAnchorButton' href='#' onclick='watchedMode=&quot;"+md+"&quot;; setDisplayConfig(&quot;BandDetails&quot;,&quot;"+band+"&quot;);'>"+md+"</a> ";
         });
        if(op.innerHTML.length>0) {op.innerHTML="+ "+op.innerHTML};
  }
 
  function showBandDetails(){
     
     legend.innerHTML="";
     detailsTop.innerHTML="<div><strong>"+detailsBand+" "+watchedMode+" Band Activity Details</strong>"
          +"<br>Total "+document.getElementById(detailsBand+"__spots").innerHTML+"<br>"+spotsLegend+"<br>"
          +document.getElementById(detailsBand+"__calls").innerHTML+"<br>"
          +"</div><div>"
          +" <a href='#' onclick=setDisplayConfig(&quot;BandTileLegend&quot;);><span style='float:right;';>close</span></a>"
	  +"<span class='notesText'><br>Entities reached both by "+myCall+" and home Tx calls are "+HL("highlighted",true,"HighlightPos")+".</span>"
          +"<br><span class='notesText'>Entities spotted both by "+myCall+" and home Rx calls are "+HL("highlighted",true,"HighlightPos")+".</span>"
	  +"<br><span class='notesText'> Entities reached and/or spotted only by "+myCall+" are "+HL("highlighted",true,"HighlightNeg")+".</span>"
          +"</div>";
		
        detailsGrid.innerHTML="<div class='titleRow'>"
          +"<strong>Home <span class='Tx'>Tx Calls</span>, <span class='Rx'>Rx Calls</span> and <span class='TxRx'>Tx-Rx Calls</span></strong>"
          +" <br><a class='textAnchorButton' href='#' onclick='groupHomeEntities=false; updateDisplays();'>[List&nbsp;each&nbsp;call]</a>"
          +" <a class='textAnchorButton' href='#' onclick='groupHomeEntities=true; updateDisplays();'>[Group&nbsp;into&nbsp;Tx&nbsp;and&nbsp;Rx]</a>"
          +"</div><div></div>"
          +"<div class='titleRow'><strong>Entities reached by <span class='Tx'>Tx Calls</span>, "
	  +"spotted by <span class='Rx'>Rx Calls</span>, and both reached and spotted by any <span class='TxRx'>Tx-Rx Call</span></strong><br>"
          +"<span class='notesText'>Home calls can be listed as Tx-Rx and yet have no reciprocal spots with any remote entity</span>"
	  +"<span class='notesText'><br>Choosing coarser definitions of remote entities makes reciprocal spots more likely but not inevitable</span>"
          +"<br><a class='textAnchorButton' href='#' onclick='entityDisplayType=&quot;Square&quot;;squaresDisplayLevel=2; updateDisplays();'>[Entity=&nbsp;level&nbsp;2&nbsp;square]</a>"
          +" <a class='textAnchorButton' href='#' onclick='entityDisplayType=&quot;Square&quot;;squaresDisplayLevel=4; updateDisplays();'>[Entity=&nbsp;level&nbsp;4&nbsp;square]</a>"
          +" <a class='textAnchorButton' href='#' onclick='entityDisplayType=&quot;Square&quot;;squaresDisplayLevel=6; updateDisplays();'>[Entity=&nbsp;level&nbsp;6&nbsp;square]</a>"
	  +" <a class='textAnchorButton' href='#' onclick='entityDisplayType=&quot;Call&quot;; updateDisplays();'>[Entity=&nbsp;callsign]</a></div>";
    
       // get home call data and HTML for all calls except myCall, then myCall only, then compare to highlight
	  
       // all except myCall:
       objHomeCallData=getConnectionsData(myCall,true);
       let othersTxHTML=getBandDetailsRowHTML(objHomeCallData,"Tx","othersTx");
       let othersRxHTML=getBandDetailsRowHTML(objHomeCallData,"Rx","othersRx");
       let othersTxRxHTML=getBandDetailsRowHTML(objHomeCallData,"TxRx","othersTxRx");
       
       // just myCall
       objHomeCallData=getConnectionsData(myCall,false);
       let myCallTxHTML=getBandDetailsRowHTML(objHomeCallData,"Tx","myCallTx");
       let myCallRxHTML=getBandDetailsRowHTML(objHomeCallData,"Rx","myCallRx");
       let myCallTxRxHTML=getBandDetailsRowHTML(objHomeCallData,"TxRx","myCallTxRx");   
      
       detailsGrid.innerHTML+=othersTxHTML+othersRxHTML+othersTxRxHTML
         +myCallTxHTML+myCallRxHTML+myCallTxRxHTML;
         
       // do the highlighting

       highlightAll("myCallRx");
       highlightAll("myCallTx");
       highlightAll("myCallTxRx"); 	 
	  
       highlightEntitiesList("myCallRx","othersRx");
       highlightEntitiesList("myCallRx","othersTxRx");

       highlightEntitiesList("myCallTx","othersTx"); 
       highlightEntitiesList("myCallTx","othersTxRx"); 

       highlightEntitiesList("myCallTxRx","othersTxRx"); 
     
         
}	

function highlightAll(myCallrowClassPrefix){
  // pre-highlight all myCall entries in 'only me' colours HighlightNeg
  const farEntities_me=document.getElementById("detailsGrid").getElementsByClassName(myCallrowClassPrefix+"_farEntities");  
  if (farEntities_me[0]!=undefined){
    // plain text version of far entities to highlight
    let farEntities_meTxt=farEntities_me[0].innerText.split(', ');
    // loop through the farEntities in my list, modifying the innerHTML
    for (let i=0;i<farEntities_me.length;i++){
      farEntities_meTxt.forEach(entity => {
        farEntities_me[i].innerHTML=farEntities_me[i].innerHTML.replace(entity,HL(entity,true,"HighlightNeg"));
      });
    }
  }
}


function highlightEntitiesList(myCallrowClassPrefix,othersRowClassPrefix){

  const farEntities_me=document.getElementById("detailsGrid").getElementsByClassName(myCallrowClassPrefix+"_farEntities");  
  const farEntities_others=document.getElementById("detailsGrid").getElementsByClassName(othersRowClassPrefix+"_farEntities");
      
  if (farEntities_me[0]!=undefined && farEntities_others[0]!=undefined){
    // plain text version of far entities to look for in other call's far entities
    let farEntities_meTxt=farEntities_me[0].innerText.split(', ');
    // loop through the farEntities_others collection so it works with 'grouped home calls' and 'list all'
    for (let i=0;i<farEntities_others.length;i++){
      // highlight the matches in the other call's far entities
      farEntities_meTxt.forEach(entity => {
        farEntities_others[i].innerHTML=farEntities_others[i].innerHTML.replace(entity,HL(entity,true));
      });
      // highlight the (same) matches in myCall's far entities, first reversing out the pre-highlighting
      let farEntities_othersTxt=farEntities_others[i].innerText.split(', ');
      farEntities_othersTxt.forEach(entity => {
	farEntities_me[0].innerHTML=farEntities_me[0].innerHTML.replace("<span class='HighlightNeg'>"+entity+"</span>",entity);
        farEntities_me[0].innerHTML=farEntities_me[0].innerHTML.replace(entity,HL(entity,true));
      });
    }
  }
  
}

function getConnectionsData(specificHomeCall,exclude){
       // create an object objHomeCalldata[connections[id].hc]= {call, isTx, isRx,conns:{}}
       //     - unique home calls transmitting and/or receiving on the watchedMode and detailsBand
       //     - each unique home call carries boolean tx & rx flags and connections to far entities
       //     - each far entity = {call or square, am I in home?}
       // then accumulate the entries from connections:
       // connections - sq:sequence, t:time, b:band, md:mode, dd:direction = hh,hd or dh
       //               hc:home, call hl:home loc, cc:connected call, cl:connected call loc
       
       // if specificHomeCall, only do this for the specified home call
       // if exclude, do it for all home calls except the specified home call
      var objHomeCallData={};
       for (id in connections) {
         if (connections[id].b==detailsBand && connections[id].md==watchedMode 
           && ( (exclude && connections[id].hc!=specificHomeCall) || (!exclude && connections[id].hc==specificHomeCall)) ){
           objHomeCallData[connections[id].hc]={call:connections[id].hc,isTx:false,isRx:false,conns:{}};
         }
       }
       reciprocals.clear();
       for (id in connections) {
         if (connections[id].b==detailsBand && connections[id].md==watchedMode 
           && ( (exclude && connections[id].hc!=specificHomeCall) || (!exclude && connections[id].hc==specificHomeCall)) ){
           if(connections[id].dd[0]=="h") {objHomeCallData[connections[id].hc].isTx=true} 
           if(connections[id].dd[0]=="d") {objHomeCallData[connections[id].hc].isRx=true}
           farEntity=getEntity(connections[id].cc,connections[id].cl);
           objHomeCallData[connections[id].hc].conns[farEntity]=squareIsInHome(connections[id].cl);
           reciprocals.add(connections[id].hc+","+farEntity+","+connections[id].dd[0])
         }      
       }
       
       return objHomeCallData;
}

function getBandDetailsRowHTML(objHomeCallData,TxRx,rowClassPrefix){
	
  let homeCalls=new Array(); // OK because we're going to add unique values
  let localConnectedEntitiesGrouped=new Set;  // local means the connected entity is also in Home
  let nonlocalConnectedEntitiesGrouped=new Set; // nonlocal means the conected entity is not in Home
  let tmpHTML="";
  let Arrow="";
  if (TxRx=="Tx"){Arrow=RIGHTARROW}
  if (TxRx=="Rx"){Arrow=LEFTARROW}
  if (TxRx=="TxRx"){Arrow=LEFTRIGHTARROW}
  for (const homeCall in objHomeCallData) {
     if(((TxRx=="Tx") && objHomeCallData[homeCall].isTx)
     || ((TxRx=="Rx") && objHomeCallData[homeCall].isRx) 
     || ((TxRx=="TxRx") && (objHomeCallData[homeCall].isTx && objHomeCallData[homeCall].isRx))) {
       let localConnectedEntities=new Set;
       let nonlocalConnectedEntities=new Set;
       for(const farEntity in objHomeCallData[homeCall].conns) {
         let reciprocal=false;
         if(TxRx){
           let outlink=homeCall+","+farEntity+",h";
           let inlink=homeCall+","+farEntity+",d";
           reciprocal=(reciprocals.has(outlink) && reciprocals.has(inlink));
         }
         if( TxRx!="TxRx" || (TxRx=="TxRx" && reciprocal) ) {
           if(objHomeCallData[homeCall].conns[farEntity]==true) { // home vs other flag (remote entity)
             localConnectedEntities.add(farEntity);
             localConnectedEntitiesGrouped.add(farEntity);
           } else {
             nonlocalConnectedEntities.add(farEntity);
             nonlocalConnectedEntitiesGrouped.add(farEntity);
           }
         }
       }
       if(groupHomeEntities){ 
         homeCalls.push(homeCall);
       } else {
         tmpHTML+="<div class='"+rowClassPrefix+"_homeCalls'><span class='"+TxRx+"'>"+homeCall+"</span></div><div class='detail_c'>"+Arrow+"</div>";
         tmpHTML+="<div class='"+rowClassPrefix+"_farEntities'><span class='IntraHome_farEnd'>"+Array.from(localConnectedEntities).toSorted().join(', ')+"</span>";
         if(localConnectedEntities.size>0 && nonlocalConnectedEntities.size>0) {tmpHTML+=", "};
         tmpHTML+="<span class='"+TxRx+"_farEnd'>"+Array.from(nonlocalConnectedEntities).toSorted().join(', ')+"</span></div>";
       }
     }
   }
   if (groupHomeEntities){
     if (homeCalls.length>0){
       tmpHTML="<div class='"+rowClassPrefix+"_homeCalls'><span class='"+TxRx+"'>"+homeCalls.toSorted().join(', ')+"</span></div><div class='detail_c'>"+Arrow+"</div>";
       tmpHTML+="<div class='"+rowClassPrefix+"_farEntities'><span class='IntraHome_farEnd'>"+Array.from(localConnectedEntitiesGrouped).toSorted().join(', ')+"</span>";
       if(localConnectedEntitiesGrouped.size>0 && nonlocalConnectedEntitiesGrouped.size>0) {tmpHTML+=", "};
       tmpHTML+="<span class='"+TxRx+"_farEnd'>"+Array.from(nonlocalConnectedEntitiesGrouped).toSorted().join(', ')+"</span></div>";
     }
   }
   return tmpHTML;
}



</script>
	
</body>
</html>
